class MyException : Exception {
    MyException([string]$Message) : base($Message) {}
}

class MyArchiveConfig {
    [string] $RootPath
    MyArchiveConfig([string]$RootPath) {
        $this.RootPath = $RootPath
    }
}

class MyArchiveConfigFactory {
    static [string] $DEFAULT_ROOT_PATH = '.\Archives'

    static [MyArchiveConfig] Create([PSCustomObject]$ConfigPso) {
        $RootPath = $ConfigPso.RootPath
        if ($null -eq $RootPath) {
            $RootPath = [MyArchiveConfigFactory]::DEFAULT_ROOT_PATH
        }
        return [MyArchiveConfig]::new($RootPath)
    }
}

class MyArchiver {
    [string] $SourcePath
    [string] $ArchiveJsonPath
    [MyArchiveConfig] $ArchiveConfig
    [string] $ArchiveRootPath
    [string] $YearFolderPath
    [string] $DestinationPath

    MyArchiver([string]$SourcePath, [string]$ArchiveJsonPath, [MyArchiveConfig]$ArchiveConfig, [string]$ArchiveRootPath, [string]$YearFolderPath, [string]$DestinationPath) {
        $this.SourcePath = $SourcePath
        $this.ArchiveJsonPath = $ArchiveJsonPath
        $this.ArchiveConfig = $ArchiveConfig
        $this.ArchiveRootPath = $ArchiveRootPath
        $this.YearFolderPath = $YearFolderPath
        $this.DestinationPath = $DestinationPath
    }

    MakeArchiveRootFolder() {
        if (-not (Test-Path -LiteralPath $this.ArchiveRootPath)) {
            New-Item -ItemType Directory -Path $this.ArchiveRootPath -ErrorAction Stop | Out-Null
        }
    }

    MakeYearFolder() {
        if (-not (Test-Path -LiteralPath $this.YearFolderPath)) {
            New-Item -ItemType Directory -Path $this.YearFolderPath -ErrorAction Stop | Out-Null
        }
    }

    Archive() {
        Move-Item -LiteralPath $this.SourcePath -Destination $this.DestinationPath
    }
}

class MyArchiverFactory {
    static [string] $ArchiveConfigJsonName = ".archiveconfig.json"

    static hidden [DateTime] GetDateFromPath([string]$Path) {
        $Name = Split-Path -Leaf $Path

        $DatePatterns = @(
            "^\d{4}\d{2}\d{2}"
        )

        $Found = $false
        foreach ($DatePattern in $DatePatterns) {
            if ($Name -match $DatePattern) {
                $Found = $true
                break
            }
        }
        if (-not $Found) {
            $Message = "DatePattern not found. Folder names must begin with an 8-digit number representing the date. (Path: {0})" -f $Path
            throw [MyException]::new($Message)
        }

        $ParsedDate = [DateTime]::MinValue;
        $String = $Matches[0]
        $Format = "yyyyMMdd"
        $Provider = $null
        $Style = [System.Globalization.DateTimeStyles]::None
        if (-not [DateTime]::TryParseExact($String, $Format, $Provider, $Style, [ref]$ParsedDate)) {
            $Message = "TryParseExact() failed. (Path: {0})" -f $Path
            throw [MyException]::new($Message)
        }
        return $ParsedDate
    }

    static hidden TestItemCanBeArchived([string]$SourcePath) {
        if (-not (Test-Path -LiteralPath $SourcePath)) {
            $Message = "SourcePath is not exist. (SourcePath: {0})" -f $SourcePath
            throw [MyException]::new($Message)
        }

        $SourceItem = Get-Item -LiteralPath $SourcePath
        if ($SourceItem.Name -eq [MyArchiverFactory]::ArchiveConfigJsonName) {
            $Message = "SourcePath is ArchiveConfigJson. (SourcePath: {0})" -f $SourcePath
            throw [MyException]::new($Message)
        }
        if ($SourceItem.PSIsContainer) {
            $Items = Get-ChildItem -LiteralPath $SourceItem.FullName -Recurse -Filter [MyArchiverFactory]::ArchiveConfigJsonName
            if ($Items.Count -gt 0) {
                $ArchiveJsonPathArray = $Items | ForEach-Object { $_.FullName }
                $Message = "SourcePath contains ArchiveConfigJson. ({0})" -f $ArchiveJsonPathArray
                throw [MyException]::new($Message)
            }
        }

        if ($SourcePath.Name -match '^\d{4}') {
            $Message = "SourcePath is year folder? (SourcePath: {0})" -f $SourcePath
            throw [MyException]::new($Message)
        }

    }

    static hidden [string]GetArchiveConfigJsonPath([string]$SourcePath) {
        $Item = Get-Item -LiteralPath $SourcePath
        while ($null -ne $Item) {
            $Name = [MyArchiverFactory]::ArchiveConfigJsonName
            $ArchiveJsonPath = Join-Path $Item.FullName $Name
            if (Test-Path -LiteralPath $ArchiveJsonPath) {
                return $ArchiveJsonPath
            }
            $Item = $Item.Parent
        }

        $Message = "ArchiveConfigJson is not found. (SourcePath: {0})" -f $SourcePath
        throw [MyException]::new($Message)
    }

    static hidden [MyArchiveConfig]GetArchiveConfig([string]$ArchiveConfigJsonPath) {
        $ConfigJsonContent = Get-Content -LiteralPath $ArchiveConfigJsonPath -Raw
        $ConfigPso = $ConfigJsonContent | ConvertFrom-Json
        [MyArchiveConfig] $ArchiveConfig = [MyArchiveConfigFactory]::Create($ConfigPso)
        return $ArchiveConfig
    }

    static hidden [string]GetArchiveRootPath([string]$ArchiveConfigJsonDirectoryPath, [MyArchiveConfig]$Config) {
        if ($Config.RootPath -match '^\.\\') {
            $RootPath = $Config.RootPath.Substring(2)
            $ArchiveRootPath = Join-Path $ArchiveConfigJsonDirectoryPath $RootPath
        } else {
            $ArchiveRootPath = $Config.RootPath
        }
        return $ArchiveRootPath
    }

    static [MyArchiver] Create([string]$SourcePath) {
        $Name = Split-Path -Leaf $SourcePath

        $Date = [MyArchiverFactory]::GetDateFromPath($SourcePath)
        [MyArchiverFactory]::TestItemCanBeArchived($SourcePath)

        $ArchiveConfigJsonPath = [MyArchiverFactory]::GetArchiveConfigJsonPath($SourcePath)

        $ArchiveConfig = [MyArchiverFactory]::GetArchiveConfig($ArchiveConfigJsonPath)

        $ArchiveConfigJsonDirectoryPath = Split-Path -Parent $ArchiveConfigJsonPath
        $ArchiveRootPath = [MyArchiverFactory]::GetArchiveRootPath($ArchiveConfigJsonDirectoryPath, $ArchiveConfig)

        $YearFolderPath = Join-Path $ArchiveRootPath $Date.ToString("yyyy")

        $DestinationPath = Join-Path $YearFolderPath $Name

        return [MyArchiver]::new($SourcePath, $ArchiveConfigJsonPath, $ArchiveConfig, $ArchiveRootPath, $YearFolderPath, $DestinationPath)
    }
}

class MyDatePrefixedFolderMaker {
    [string] $SourcePath
    [string] $DestinationFolder
    [string] $DestinationPath

    MyDatePrefixedFolderMaker([string]$SourcePath, [string]$DestinationFolder, [string]$DestinationPath) {
        $this.SourcePath = $SourcePath
        $this.DestinationFolder = $DestinationFolder
        $this.DestinationPath = $DestinationPath
    }
    MakeFolder() {
        if (-not (Test-Path -LiteralPath $this.DestinationFolder)) {
            New-Item -ItemType Directory -Path $this.DestinationFolder -ErrorAction Stop | Out-Null
        }
    }
    MoveToDestination() {
        if (Test-Path -LiteralPath $this.DestinationPath) {
            $Message = "DestinationPath already exists. (DestinationPath: {0})" -f $this.DestinationPath
            throw [MyException]::new($Message)
        }
        Move-Item -LiteralPath $this.SourcePath -Destination $this.DestinationPath
    }
}

class MyDatePrefixedFolderMakerFactory {
    static hidden [DateTime] GetDateFromPath([string]$Path) {
        $DatePatterns = @(
            "^\d{4}\d{2}\d{2}"
        )

        $Found = $false
        foreach ($DatePattern in $DatePatterns) {
            if ($Path -match $DatePattern) {
                $Found = $true
                break
            }
        }
        if (-not $Found) {
            $Message = "DatePattern not found. (Path: {0})" -f $Path
            throw [MyException]::new($Message)
        }

        $ParsedDate = [DateTime]::MinValue;
        $String = $Matches[0]
        $Format = "yyyyMMdd"
        $Provider = $null
        $Style = [System.Globalization.DateTimeStyles]::None
        if (-not [DateTime]::TryParseExact($String, $Format, $Provider, $Style, [ref]$ParsedDate)) {
            $Message = "TryParseExact failed. (Path: {0})" -f $Path
            throw [MyException]::new($Message)
        }
        return $ParsedDate
    }

    static hidden [string] GetDestinationFolder([string]$SourcePath) {
        $ParentDirectoryPath = Split-Path -Parent $SourcePath

        $OriginalName = Split-Path -Leaf $SourcePath
        try {
            [MyDatePrefixedFolderMakerFactory]::GetDateFromPath($SourcePath) | Out-Null
            $Name = $OriginalName
        } catch {
            $Date = Get-Date
            $Prefix = Get-Date -Date $Date -Format "yyyyMMdd"
            $Name = "{0}_{1}" -f $Prefix, $OriginalName
        }

        $DestinationFolder = Join-Path $ParentDirectoryPath $Name
        return $DestinationFolder
    }

    static [MyDatePrefixedFolderMaker] Create([string]$SourcePath) {
        $DestinationFolder = [MyDatePrefixedFolderMakerFactory]::GetDestinationFolder($SourcePath)

        $Name = Split-Path -Leaf $SourcePath
        $DestinationPath = Join-Path $DestinationFolder $Name

        return [MyDatePrefixedFolderMaker]::new($SourcePath, $DestinationFolder, $DestinationPath)
    }
}

function New-MyArchiveConfigJson {
<#
.SYNOPSIS
アーカイブ設定ファイルを作成します。

.DESCRIPTION
アーカイブ設定ファイルを作成します。

.EXAMPLE
New-MyArchiveConfigJson
#>
    [CmdletBinding()]
    param ()

    $Config = [pscustomobject]@{"RootPath" = [MyArchiveConfigFactory]::DEFAULT_ROOT_PATH}
    $ConfigJson = $Config | ConvertTo-Json
    $ConfigJson
}

function Move-MyFolderItemToArchiveFolder {
<#
.SYNOPSIS
指定したフォルダをアーカイブフォルダに移動します。

.DESCRIPTION
指定したフォルダをアーカイブフォルダに移動します。

.PARAMETER LiteralSourcePathList
LiteralSourcePathList

.PARAMETER LiteralSourcePath
LiteralSourcePath

.EXAMPLE
Move-MyItemToArchiveFolder -LiteralSourcePathList @("C:\path1", "C:\path2")
#>
    [CmdletBinding(SupportsShouldProcess=$true)]
    param (
        [Parameter(Position=0, ValueFromPipeline=$true)]
        [string[]]$LiteralSourcePathList,

        [Parameter(Position=1)]
        [string]$LiteralSourcePath

    )
    process {
        if ($LiteralSourcePathList.Count -eq 0) {
            $LiteralSourcePathList = @($LiteralSourcePath)
        }
        foreach ($p in $LiteralSourcePathList) {
            $a = [MyArchiverFactory]::Create($p)
            if (-not (Test-Path -LiteralPath $a.ArchiveRootPath)) {
                if ($PSCmdlet.ShouldProcess($a.SourcePath, "Make directory " + $a.ArchiveRootPath)) {
                    $a.MakeArchiveRootFolder()
                }
            }
            if (-not (Test-Path -LiteralPath $a.YearFolderPath)) {
                if ($PSCmdlet.ShouldProcess($a.SourcePath, "Make directory " + $a.YearFolderPath)) {
                    $a.MakeYearFolder()
                }
            }
            if ($PSCmdlet.ShouldProcess($a.SourcePath, "Move to " + $a.DestinationPath)) {
                $a.Archive()
            }
        }
    }
}

function Move-MyFileItemToDatePrefixedFolder {
<#
.SYNOPSIS
指定されたファイルを日付付きフォルダに移動します。

.DESCRIPTION
指定されたファイルを日付付きフォルダに移動します。

.PARAMETER LiteralSourcePathList
LiteralSourcePathList

.PARAMETER LiteralSourcePath
LiteralSourcePath

.EXAMPLE
Move-MyFileItemToDatePrefixedFolder -LiteralSourcePathList @("C:\path1", "C:\path2")
#>
    [CmdletBinding(SupportsShouldProcess=$true)]
    param (
        [Parameter(Position=0, ValueFromPipeline=$true)]
        [string[]]$LiteralSourcePathList,

        [Parameter(Position=1)]
        [string]$LiteralSourcePath
    )

    process {
        if ($LiteralSourcePathList.Count -eq 0) {
            $LiteralSourcePathList = @($LiteralSourcePath)
        }
        foreach ($p in $LiteralSourcePathList) {
            $m = [MyDatePrefixedFolderMakerFactory]::Create($p)
            if ($PSCmdlet.ShouldProcess($m.SourcePath, "Make directory " + $m.DestinationFolder)) {
                $m.MakeFolder()
            }
            if ($PSCmdlet.ShouldProcess($m.SourcePath, "Move to " + $m.DestinationPath)) {
                $m.MoveToDestination()
            }
        }
    }
}
