# vim:ft=ps1:

class MyException : Exception {
    MyException([string]$Message) : base($Message) {}
}

function Test-MyDatePrefixedString {
    param([parameter(Mandatory=$true)][string]$Path)

    $DatePatterns = @(
        "^\d{4}\d{2}\d{2}"
    )

    $Found = $false
    foreach ($DatePattern in $DatePatterns) {
        if ($Path -match $DatePattern) {
            $Found = $true
            break
        }
    }
    if (-not $Found) {
        return $false
    }

    $ParsedDate = [DateTime]::MinValue;
    $String = $Matches[0]
    $Format = "yyyyMMdd"
    $Provider = $null
    $Style = [System.Globalization.DateTimeStyles]::None
    return [DateTime]::TryParseExact($String, $Format, $Provider, $Style, [ref]$ParsedDate)
}

function Get-MyDestinationPath {
    param (
        [parameter(Mandatory=$true)]
        [string]$SourcePath
    )

    $SourceItem = Get-Item -LiteralPath $SourcePath
    if ($SourceItem.PSIsContainer) {
        $Message = "SourcePath is not a file. (SourcePath: {0})" -f $SourcePath
        throw [MyException]::new($Message)
    }

    if (Test-MyDatePrefixedString -Path $SourceItem.BaseName) {
        $BaseName = $SourceItem.BaseName
        $Message = "SourcePath is already DatePrefixed. (BaseName: {0})" -f $BaseName
        Write-Host $Message
    } else {
        $Prefix = Get-Date -Format "yyyyMMdd"
        $BaseName = "{0}_{1}" -f $Prefix, $SourceItem.BaseName
    }
    $FolderPath = Join-Path $SourceItem.DirectoryName $BaseName

    return $FolderPath
}

function Move-MyOneFileItemToDatePrefixedFolder {
    [CmdletBinding(SupportsShouldProcess=$true)]
    param (
        [Parameter(Mandatory=$true)]
        [string]$LiteralSourcePath
    )

    if (-not (Test-Path -Path $LiteralSourcePath)) {
        $Message = "SourcePath does not exist. (LiteralSourcePath: {0})" -f $LiteralSourcePath
        Write-Error $Message
        return
    }

    # ファイル名からフォルダを作る
    $FolderPath = Get-MyDestinationPath -SourcePath $LiteralSourcePath
    if (Test-Path -Path $FolderPath) {
        $Message = "DestinationPath already exists. FolderPath: {0}" -f $FolderPath
        Write-Error $Message
        return
    }
    New-Item -ItemType Directory -Path $FolderPath -ErrorAction Stop | Out-Null

    # ファイルをフォルダに移動する
    Move-Item -LiteralPath $LiteralSourcePath -Destination $FolderPath
}

function Move-MyFileItemToDatePrefixedFolder {
<#
.SYNOPSIS
指定ファイルを日付を接頭に持つフォルダを作って、そのフォルダに移動する
#>
    [CmdletBinding()]
    param (
        [Parameter(Position=0, ValueFromPipeline=$true)]
        [string[]]$LiteralSourcePathList,

        [Parameter(Position=1)]
        [string]$LiteralSourcePath

    )
    process {
        if ($LiteralSourcePathList.Count -eq 0) {
            $LiteralSourcePathList = @($LiteralSourcePath)
        }
        foreach ($p in $LiteralSourcePathList) {
            Move-MyOneFileItemToDatePrefixedFolder -LiteralSourcePath $p
        }
    }
}

function Get-MyArchiveRootDirectoryPath {
    param(
        [parameter(Mandatory=$true)]
        [string]$DirectoryPath
    )

    $ArchiveRootName = ".archive_root"

    $ArchiveRootPath = $null

    $DirectoryItem = Get-Item -LiteralPath $DirectoryPath
    $Current = $DirectoryItem
    while ($null -ne $Current) {
        $DotArchiveRootPath = Join-Path $Current.FullName $ArchiveRootName
        if (Test-Path -Path $DotArchiveRootPath) {
            $ArchiveRootPath = $Current.FullName
            return $ArchiveRootPath
        }
        $Current = $Current.Parent
    }

    if ($null -eq $ArchiveRootPath) {
        $Message = "ArchiveRootName {0} not found. (DirectoryPath: {1})" -f $ArchiveRootName, $DirectoryPath
        throw [MyException]::new($Message)
    }
}

function Move-MyOneDatePrefixedFolderItemToArchiveFolder {
    param (
        [Parameter(Mandatory=$true)]
        [string]$LiteralSourcePath
    )

    # パスが存在するか？
    if (-not (Test-Path -Path $LiteralSourcePath)) {
        $Message = "SourcePath does not exist. (LiteralSourcePath: {0})" -f $LiteralSourcePath
        throw [MyException]::new($Message)
    }

    # パスはディレクトリか？
    if (-not (Test-Path -Path $LiteralSourcePath -PathType Container)) {
        $Message = "SourcePath is not a folder. (LiteralSourcePath: {0})" -f $LiteralSourcePath
        throw [MyException]::new($Message)
    }

    # アーカイブ・ルートのパスを得る。
    $SourceItem = Get-Item -LiteralPath $LiteralSourcePath
    $ArchiveRootPath = Get-MyArchiveRootDirectoryPath -DirectoryPath $SourceItem.FullName

    # パスは無視すべきディレクトリか？
    # アーカイブ・ディレクトリの構造を破壊しないために、一部のディレクトリは無視する。
    $IgnorePatterns = @(
        @{"Pattern"="^\d{4}$"; "Reason"="Maybe a year folder?"}
    )
    foreach ($p in $IgnorePatterns) {
        if ($SourceItem.Name -match $p.Pattern) {
            $Message = "Ignored. Reason: {0} (LiteralSourcePath: {1})" -f $p.Reason, $LiteralSourcePath
            Write-Host $Message
            return
        }
    }

    # 西暦のフォルダがなければ作る。
    $FolderName = Split-Path -Path $LiteralSourcePath -Leaf
    $DatePrefix = $FolderName.Substring(0, 8)
    $Year = $DatePrefix.Substring(0, 4)
    $YearFolderPath = Join-Path $ArchiveRootPath $Year
    if (-not (Test-Path -Path $YearFolderPath)) {
        New-Item -ItemType Directory -Path $YearFolderPath -ErrorAction Stop | Out-Null
    }

    # 移動する。
    $DestinationPath = Join-Path $YearFolderPath $FolderName
    Move-Item -LiteralPath $LiteralSourcePath -Destination $DestinationPath
}

function Move-MyDatePrefixedFolderItemToArchiveFolder {
<#
.SYNOPSIS
指定フォルダをアーカイブ・フォルダに移動する

.DESCRIPTION
指定フォルダの上位ディレクトリをたどって最も近い `.archive_root` を探し、
その下に、西暦のフォルダを作って、その中に指定フォルダを移動する。
#>
    [CmdletBinding(SupportsShouldProcess=$true)]
    param (
        [Parameter(Position=0, ValueFromPipeline=$true)]
        [string[]]$LiteralSourcePathList,

        [Parameter(Position=1)]
        [string]$LiteralSourcePath
    )

    process {
        if ($LiteralSourcePathList.Count -eq 0) {
            $LiteralSourcePathList = @($LiteralSourcePath)
        }
        foreach ($p in $LiteralSourcePathList) {
            Move-MyOneDatePrefixedFolderItemToArchiveFolder -LiteralSourcePath $p
        }
    }
}
